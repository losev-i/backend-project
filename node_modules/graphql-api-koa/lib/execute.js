'use strict'

exports.__esModule = true
exports.execute = void 0

var _graphql = require('graphql')

var _checkOptions = require('./checkOptions')

var _checkSchema = require('./checkSchema')

var _createHttpError = require('./createHttpError')

var _isPlainObject = require('./isPlainObject')

const execute = options => {
  if (typeof options === 'undefined')
    throw (0, _createHttpError.createHttpError)(
      'GraphQL execute middleware options missing.'
    )
  if (!(0, _isPlainObject.isPlainObject)(options))
    throw (0, _createHttpError.createHttpError)(
      'GraphQL execute middleware options must be an object.'
    )
  const ALLOWED_OPTIONS = [
    'schema',
    'rootValue',
    'contextValue',
    'fieldResolver',
    'override'
  ]
  ;(0, _checkOptions.checkOptions)(
    options,
    ALLOWED_OPTIONS,
    'GraphQL execute middleware'
  )
  if (typeof options.schema !== 'undefined')
    (0, _checkSchema.checkSchema)(options.schema)
  if (
    typeof options.override !== 'undefined' &&
    typeof options.override !== 'function'
  )
    throw (0, _createHttpError.createHttpError)(
      'GraphQL execute middleware `override` option must be a function.'
    )
  return async (ctx, next) => {
    if (typeof ctx.request.body === 'undefined')
      throw (0, _createHttpError.createHttpError)('Request body missing.')
    if (!(0, _isPlainObject.isPlainObject)(ctx.request.body))
      throw (0, _createHttpError.createHttpError)(
        400,
        'Request body must be a JSON object.'
      )
    if (!('query' in ctx.request.body))
      throw (0, _createHttpError.createHttpError)(
        400,
        'GraphQL operation field `query` missing.'
      )
    let document

    try {
      document = (0, _graphql.parse)(
        new _graphql.Source(ctx.request.body.query)
      )
    } catch (error) {
      throw (0, _createHttpError.createHttpError)(
        400,
        `GraphQL query syntax error: ${error.message}`
      )
    }

    let optionsOverride = {}

    if (options.override) {
      optionsOverride = await options.override(ctx)
      if (!(0, _isPlainObject.isPlainObject)(optionsOverride))
        throw (0, _createHttpError.createHttpError)(
          'GraphQL execute middleware options must be an object, or an object promise.'
        )
      ;(0, _checkOptions.checkOptions)(
        optionsOverride,
        ALLOWED_OPTIONS.filter(option => option !== 'override'),
        'GraphQL execute middleware `override` option return'
      )
      if (typeof optionsOverride.schema !== 'undefined')
        (0, _checkSchema.checkSchema)(optionsOverride.schema)
    }

    const execute = {
      ...options,
      ...optionsOverride
    }
    const queryValidationErrors = (0, _graphql.validate)(
      execute.schema,
      document
    )
    if (queryValidationErrors.length)
      throw (0, _createHttpError.createHttpError)(
        400,
        'GraphQL query validation errors.',
        {
          graphqlErrors: queryValidationErrors
        }
      )
    let result

    try {
      result = await (0, _graphql.execute)({
        ...execute,
        document,
        variableValues: ctx.request.body.variables,
        operationName: ctx.request.body.operationName
      })
    } catch (error) {
      throw (0, _createHttpError.createHttpError)(
        400,
        `GraphQL operation field invalid: ${error.message}`
      )
    }

    if (result.data)
      ctx.response.body = {
        data: result.data
      }
    if (result.errors)
      throw (0, _createHttpError.createHttpError)(200, 'GraphQL errors.', {
        graphqlErrors: result.errors
      })
    ctx.response.status = 200
    await next()
  }
}

exports.execute = execute
