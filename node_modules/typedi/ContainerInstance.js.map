{"version":3,"sources":["../../src/ContainerInstance.ts"],"names":[],"mappings":"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","file":"ContainerInstance.js","sourcesContent":["import {Container} from \"./Container\";\nimport {MissingProvidedServiceTypeError} from \"./error/MissingProvidedServiceTypeError\";\nimport {ServiceNotFoundError} from \"./error/ServiceNotFoundError\";\nimport {Token} from \"./Token\";\nimport {ObjectType} from \"./types/ObjectType\";\nimport {ServiceIdentifier} from \"./types/ServiceIdentifier\";\nimport {ServiceMetadata} from \"./types/ServiceMetadata\";\n\n/**\n * TypeDI can have multiple containers.\n * One container is ContainerInstance.\n */\nexport class ContainerInstance {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Container instance id.\n     */\n    id: any;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * All registered services.\n     */\n    private services: ServiceMetadata<any, any>[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(id: any) {\n        this.id = id;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(type: ObjectType<T>): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(id: string): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(id: Token<T>): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(identifier: ServiceIdentifier): boolean {\n        return !!this.findService(identifier);\n    }\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(type: ObjectType<T>): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: string): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: Token<T>): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: { service: T }): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(identifier: ServiceIdentifier<T>): T {\n\n        const globalContainer = Container.of(undefined);\n        let service = globalContainer.findService(identifier);\n        let scopedService = this.findService(identifier);\n\n        if (service && service.global === true)\n            return this.getServiceValue(identifier, service);\n\n        if (scopedService)\n            return this.getServiceValue(identifier, scopedService);\n\n        if (service && this !== globalContainer) {\n            const clonedService = Object.assign({}, service);\n            clonedService.value = undefined;\n            const value = this.getServiceValue(identifier, clonedService);\n            this.set(identifier, value);\n            return value;\n        }\n\n        return this.getServiceValue(identifier, service);\n    }\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: string): T[];\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: Token<T>): T[];\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: string|Token<T>): T[] {\n        return this.filterServices(id).map(service => this.getServiceValue(id, service));\n    }\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set<T, K extends keyof T>(service: ServiceMetadata<T, K>): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(type: Function, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(name: string, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(token: Token<any>, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(token: ServiceIdentifier, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set<T, K extends keyof T>(values: ServiceMetadata<T, K>[]): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(identifierOrServiceMetadata: ServiceIdentifier|ServiceMetadata<any, any>|(ServiceMetadata<any, any>[]), value?: any): this {\n        if (identifierOrServiceMetadata instanceof Array) {\n            identifierOrServiceMetadata.forEach((v: any) => this.set(v));\n            return this;\n        }\n        if (typeof identifierOrServiceMetadata === \"string\" || identifierOrServiceMetadata instanceof Token) {\n            return this.set({ id: identifierOrServiceMetadata, value: value });\n        }\n        if (typeof identifierOrServiceMetadata === \"object\" && (identifierOrServiceMetadata as { service: Token<any> }).service) {\n            return this.set({ id: (identifierOrServiceMetadata as { service: Token<any> }).service, value: value });\n        }\n        if (identifierOrServiceMetadata instanceof Function) {\n            return this.set({ type: identifierOrServiceMetadata, id: identifierOrServiceMetadata, value: value });\n        }\n\n        // const newService: ServiceMetadata<any, any> = arguments.length === 1 && typeof identifierOrServiceMetadata === \"object\"  && !(identifierOrServiceMetadata instanceof Token) ? identifierOrServiceMetadata : undefined;\n        const newService: ServiceMetadata<any, any> = identifierOrServiceMetadata as any;\n        const service = this.findService(newService.id);\n        if (service && service.multiple !== true) {\n            Object.assign(service, newService);\n        } else {\n            this.services.push(newService);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes services with a given service identifiers (tokens or types).\n     */\n    remove(...ids: ServiceIdentifier[]): this {\n        ids.forEach(id => {\n            this.filterServices(id).forEach(service => {\n                this.services.splice(this.services.indexOf(service), 1);\n            });\n        });\n        return this;\n    }\n\n    /**\n     * Completely resets the container by removing all previously registered services from it.\n     */\n    reset(): this {\n        this.services = [];\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Filters registered service in the with a given service identifier.\n     */\n    private filterServices(identifier: ServiceIdentifier): ServiceMetadata<any, any>[] {\n        return this.services.filter(service => {\n            if (service.id)\n                return service.id === identifier;\n\n            if (service.type && identifier instanceof Function)\n                return service.type === identifier || identifier.prototype instanceof service.type;\n\n            return false;\n        });\n    }\n\n    /**\n     * Finds registered service in the with a given service identifier.\n     */\n    private findService(identifier: ServiceIdentifier): ServiceMetadata<any, any>|undefined {\n        return this.services.find(service => {\n            if (service.id) {\n                if (identifier instanceof Object &&\n                    service.id instanceof Token &&\n                    (identifier as any).service instanceof Token) {\n                    return service.id === (identifier as any).service;\n                }\n\n                return service.id === identifier;\n            }\n\n            if (service.type && identifier instanceof Function)\n                return service.type === identifier; // todo: not sure why it was here || identifier.prototype instanceof service.type;\n\n            return false;\n        });\n    }\n\n    /**\n     * Gets service value.\n     */\n    private getServiceValue(identifier: ServiceIdentifier, service: ServiceMetadata<any, any>|undefined): any {\n\n        // find if instance of this object already initialized in the container and return it if it is\n        if (service && service.value !== undefined)\n            return service.value;\n\n        // if named service was requested and its instance was not found plus there is not type to know what to initialize,\n        // this means service was not pre-registered and we throw an exception\n        if ((!service || !service.type) &&\n            (!service || !service.factory) &&\n            (typeof identifier === \"string\" || identifier instanceof Token))\n            throw new ServiceNotFoundError(identifier);\n\n        // at this point we either have type in service registered, either identifier is a target type\n        let type = undefined;\n        if (service && service.type) {\n            type = service.type;\n\n        } else if (service && service.id instanceof Function) {\n            type = service.id;\n\n        } else if (identifier instanceof Function) {\n            type = identifier;\n\n        // } else if (identifier instanceof Object && (identifier as { service: Token<any> }).service instanceof Token) {\n        //     type = (identifier as { service: Token<any> }).service;\n        }\n\n        // if service was not found then create a new one and register it\n        if (!service) {\n            if (!type)\n                throw new MissingProvidedServiceTypeError(identifier);\n\n            service = { type: type };\n            this.services.push(service);\n        }\n\n        // setup constructor parameters for a newly initialized service\n        const paramTypes = type && Reflect && (Reflect as any).getMetadata ? (Reflect as any).getMetadata(\"design:paramtypes\", type) : undefined;\n        let params: any[] = paramTypes ? this.initializeParams(type, paramTypes) : [];\n\n        // if factory is set then use it to create service instance\n        let value: any;\n        if (service.factory) {\n\n            // filter out non-service parameters from created service constructor\n            // non-service parameters can be, lets say Car(name: string, isNew: boolean, engine: Engine)\n            // where name and isNew are non-service parameters and engine is a service parameter\n            params = params.filter(param => param !== undefined);\n\n            if (service.factory instanceof Array) {\n                // use special [Type, \"create\"] syntax to allow factory services\n                // in this case Type instance will be obtained from Container and its method \"create\" will be called\n                value = (this.get(service.factory[0]) as any)[service.factory[1]](...params);\n\n            } else { // regular factory function\n                value = service.factory(...params, this);\n            }\n\n        } else {  // otherwise simply create a new object instance\n            if (!type)\n                throw new MissingProvidedServiceTypeError(identifier);\n\n            params.unshift(null);\n\n            // \"extra feature\" - always pass container instance as the last argument to the service function\n            // this allows us to support javascript where we don't have decorators and emitted metadata about dependencies\n            // need to be injected, and user can use provided container to get instances he needs\n            params.push(this);\n\n            value = new (type.bind.apply(type, params))();\n        }\n\n        if (service && !service.transient && value)\n            service.value = value;\n\n        if (type)\n            this.applyPropertyHandlers(type, value);\n\n        return value;\n    }\n\n    /**\n     * Initializes all parameter types for a given target service class.\n     */\n    private initializeParams(type: Function, paramTypes: any[]): any[] {\n        return paramTypes.map((paramType, index) => {\n            const paramHandler = Container.handlers.find(handler => handler.object === type && handler.index === index);\n            if (paramHandler)\n                return paramHandler.value(this);\n\n            if (paramType && paramType.name && !this.isTypePrimitive(paramType.name)) {\n                return this.get(paramType);\n            }\n\n            return undefined;\n        });\n    }\n\n    /**\n     * Checks if given type is primitive (e.g. string, boolean, number, object).\n     */\n    private isTypePrimitive(param: string): boolean {\n        return [\"string\", \"boolean\", \"number\", \"object\"].indexOf(param.toLowerCase()) !== -1;\n    }\n\n    /**\n     * Applies all registered handlers on a given target class.\n     */\n    private applyPropertyHandlers(target: Function, instance: { [key: string]: any }) {\n        Container.handlers.forEach(handler => {\n            if (typeof handler.index === \"number\") return;\n            if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor))\n                return;\n\n            instance[handler.propertyName] = handler.value(this);\n        });\n    }\n\n}\n"],"sourceRoot":"."}